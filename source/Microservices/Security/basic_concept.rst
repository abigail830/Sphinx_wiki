Security基础概念
==========================

提到安全的时候，首先需要搞清楚几个概念：

* `Part1. 编码、加密、哈希、模糊`_
* `Part2. Authentication认证、Authorization授权`_
* `Part3. 不同的网络安全攻击`_

  * `Cross Site Scripting (XSS)`_
  * `Cross-Site Request Forgery (XSRF or CSRF)`_


Part1. 编码、加密、哈希、模糊
-----------------------------------

Translate from： https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation

* **编码** 是为了维护数据的可用性，可以通过使用编码内容的相同算法来逆转，即不使用密钥。
* **加密** 是为了保持数据机密性，需要使用密钥(保密的)来返回明文。
* **哈希** 是通过对哈希输出的明显更改来检测内容的所有修改，从而验证内容的完整性。
* **模糊处理** 是用来防止人们理解某些东西的含义，通常与计算机代码一起使用，以帮助防止成功的逆向工程和/或产品功能的盗窃。


Encoding 编码
^^^^^^^^^^^^^^^

编码的目的是转换数据，使其能够被不同类型的系统正确(和安全地)使用，例如通过电子邮件发送的二进制数据，或者在web页面上查看特殊字符。这样做的目的不是让信息保密，而是确保信息能够被正确地消费。

编码使用一种公开可用的方案将数据转换成另一种格式，这样就可以很容易地将其颠倒过来。它不需要密钥，因为唯一需要解码的是用于编码它的算法。

例如：ACSII，UNICODE， Base64等

Encryption 加密
^^^^^^^^^^^^^^^^^^^^^

加密的目的是转换数据，使其对他人保密，例如，向某人发送一封只有他能读懂的密信，或在互联网上安全地发送密码。我们的目标不是关注可用性，而是确保数据不会被其他任何人使用，除了指定的接收者。

加密将数据转换为另一种格式，只有特定的个体才能逆转这种转换。它与明文和算法一起使用密钥来执行加密操作，密钥是保密的。因此，密文、算法和密钥都需要返回到明文。

例如： RSA，AES等

Hash 哈希
^^^^^^^^^^^

哈希的目的是确保完整性，也就是说，如果某些东西发生了变化，您可以知道它已经发生了变化。从技术上讲，哈希接受任意输入并产生一个固定长度的字符串，该字符串具有以下属性:

* 相同的输入总会产生相同的输出。
* 多个不同的输入不应该产生相同的输出。
* 从输出到输入应该是不可能的。
* 对给定输入的任何修改都应该导致对哈希的剧烈更改。

哈希经常与身份验证一起使用，以作为未修改给定消息的有力证据。这是通过接受给定的输入，对其进行哈希，然后使用发送方的私钥对散列进行签名来实现的。当收件人打开消息时，他们可以使用发件人的公钥验证哈希的签名，然后对消息本身进行哈希，并将其与发件人签名的哈希进行比较。如果它们匹配，则是由正确的人发送的未经修改的消息。

例如： sha-3， MD5

Obfuscation 模糊处理
^^^^^^^^^^^^^^^^^^^^^^^

模糊处理的目的是为了使某些东西更难理解，通常是为了使其更难攻击或复制。一种常见的用法是模糊处理源代码，这样如果对给定的产品进行逆向工程，就很难复制它。

需要注意的是，模糊处理不是一种强大的控制(就像正确使用的加密)，而是一种障碍。它与编码一样，经常可以通过相同技术来逆转。其他时候，它只是一个简单的手工过程，需要时间来完成。

关于模糊处理，需要认识到的另一个关键问题是，根据模糊的内容，代码的模糊程度是有限制的。例如，如果您模糊了计算机代码，限制是结果必须仍然是计算机可以使用的，否则应用程序将停止工作。

例如: javascript obfuscator, proguard


Part2. Authentication认证、Authorization授权
------------------------------------------------

Authentication认证
^^^^^^^^^^^^^^^^^^^^^^^^

* 认证"你是不是合格的用户？“
* 通常需要用户输入用户名、密码等信息，由后台服务（如Auth Service）进行验证
* 当验证通过后，可以基于不同的方式返回客户端（如sessionID、JWT、Token等）


Authorization授权
^^^^^^^^^^^^^^^^^^^^^^

* 验证”你是不是你？“
* 比如JWT中通过验证签名的token进行，如果是sessionID的话就需要再校验一次之前Authentication时候同时保存下来的user vs sessionID信息，从而证明你就是那个之前认证过的你
* 进而可以进行该用户对应的操作。（用户组信息也可以存在claim中包括在token信息里面，从而不用再次查询用户组获得具体权限）


Part3. 不同的网络安全攻击
------------------------------

Cross Site Scripting (XSS) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
当外部实体能够在你的网站或应用程序中执行代码时，跨站脚本攻击就会发生。如果攻击者可以在您的域上执行代码，那么您的JWT令牌就很容易受到攻击。

许多框架，包括Angular，会自动清理输入并防止任意代码执行。如果您不使用对输入/输出进行开箱即用消毒的框架，您可以查看由谷歌开发的诸如caja之类的插件来提供帮助。在许多框架和语言中，清理输入是一个已经解决的问题，建议使用框架或插件来解决这个问题。


Cross-Site Request Forgery (XSRF or CSRF)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
如果您在本地存储中使用JWT，那么ss站点请求伪造攻击就不是问题。另一方面，如果您的用例要求您将JWT存储在cookie中，那么您将需要防止XSRF。

为了简化，防止XSRF攻击，您的服务器在与客户端建立会话时将生成一个惟一的令牌(注意这不是JWT)。然后，每当将数据提交到服务器时，一个隐藏的输入字段将包含这个令牌，服务器将检查令牌是否匹配。同样，由于我们的建议是将JWT存储在本地存储器中，所以您可能不必担心XSRF攻击。



.. index:: Security, Authentication, Authorization

